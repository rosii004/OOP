1) Потребно е да дизајнирате програма за систем за хотелски резервации. За таа цел потребно е да изработите класа Room која што ќе ги има следните информации:

    број на соба - цел број
    цена за ноќевање - цел број

За оваа класа потребно е да креирате:

    Default конструктор
    Конструктор со параметри
    Copy конструктор
    Оператор =
    Функција која што ја враќа цената за едно ноќевање (getPrice)
    Функција print што ги печати информациите за собата во формат:
    [број на соба] - [цена за ноќевање] euros

Понатаму, треба да креирате класа StandardRoom. Класата треба да наследува од класата Room и дополнително да ги има следниве информации:

    hasBalcony  - bool променлива
За оваа класа потребно е да креирате:

    Default конструктор
    Конструктор со параметри
    Функција што ја враќа цената за едно ноќевање (getPrice) која што се пресметува така што доколку собата има балкон, се одзема 5% од цената што ја добивате од класата Room. Доколку собата нема балкон,цената за едно ноќевање е онаа што ја добивате од класата Room. Пример, доколку цената за ноќевање што ја добивате од класата Room е 60 евра и собата има балкон, тогаш овде функцијата треба да врати 57 евра затоа што 60 - 60 *0.05 = 57.
    Функција print што ги печати информациите за собата во формат:   [број на соба] - [цена за ноќевање] euros.  Доколку има балкон додадете 'has a balcony', доколку нема балкон додадете 'without balcony'.

Понатаму, треба да креирате класа LuxuryRoom која треба да наследува од класата Room и дополнително да ги има следниве информации:

    hasJacuzzi - bool променлива

За оваа класа потребно е да креирате:

    Default конструктор
    Конструктор со параметри
    Функција што ја враќа цената за едно ноќевање (getPrice) која што се пресметува така што доколку собата има џакузи, се додава 20% од цената што ја добивате од класата Room.Доколку собата нема џакузи,цената за едно ноќевање е онаа што ја добивате од класата Room.Пример, доколку цената за ноќевање што ја добивате од класата Room е 60 евра и собата има џакузи, тогаш овде функцијата треба да врати 72 евра затоа што 60 + 60 *0.2 = 72.
    Функција print што ги печати информациите за собата во формат:    [број на соба] - [цена за ноќевање] euros. Доколку има џакузи додадете 'has a jacuzzi', доколку нема додадете 'without jacuzzi'.

Input
4
5
Standard 204 120 1
Luxury 205 180 1
Room 206 100
Standard 207 130 0
Luxury 208 220 1

Expected
204 - 114 euros has a balcony
205 - 216 euros has a jacuzzi
206 - 100 euros
207 - 130 euros without balcony
208 - 264 euros has a jacuzzi

#include <iostream>
#include <string>
using namespace std;

class Room {
protected:
    int roomNumber;
    int pricePerNight;

public:
    Room() : roomNumber(0), pricePerNight(0) {}

    Room(int roomNumber, int pricePerNight) {
        this->roomNumber = roomNumber;
        this->pricePerNight = pricePerNight;
    }

    Room(const Room& other) {
        roomNumber = other.roomNumber;
        pricePerNight = other.pricePerNight;
    }

    Room& operator=(const Room& other) {
        if (this != &other) {
            roomNumber = other.roomNumber;
            pricePerNight = other.pricePerNight;
        }
        return *this;
    }

    virtual int getPrice() const {
        return pricePerNight;
    }

    virtual void print() const {
        cout << roomNumber << " - " << getPrice() << " euros" << endl;
    }

    virtual ~Room() {}
};

class StandardRoom : public Room {
    bool hasBalcony;

public:
    StandardRoom() : Room(), hasBalcony(false) {}

    StandardRoom(int roomNumber, int pricePerNight, bool hasBalcony)
        : Room(roomNumber, pricePerNight), hasBalcony(hasBalcony) {}

    int getPrice() const override {
        if (hasBalcony)
            return pricePerNight - static_cast<int>(pricePerNight * 0.05);
        else
            return pricePerNight;
    }

    void print() const override {
        cout << roomNumber << " - " << getPrice() << " euros ";
        cout << (hasBalcony ? "has a balcony" : "without balcony") << endl;
    }
};

class LuxuryRoom : public Room {
    bool hasJacuzzi;

public:
    LuxuryRoom() : Room(), hasJacuzzi(false) {}

    LuxuryRoom(int roomNumber, int pricePerNight, bool hasJacuzzi)
        : Room(roomNumber, pricePerNight), hasJacuzzi(hasJacuzzi) {}

    int getPrice() const override {
        if (hasJacuzzi)
            return pricePerNight + static_cast<int>(pricePerNight * 0.2);
        else
            return pricePerNight;
    }

    void print() const override {
        cout << roomNumber << " - " << getPrice() << " euros ";
        cout << (hasJacuzzi ? "has a jacuzzi" : "without jacuzzi") << endl;
    }
};

int main() {
    int testCase;
    cin >> testCase;

    if (testCase == 1) {
        // Test Room class
        int number, price;
        cin >> number >> price;
        Room r1(number, price);
        Room r2 = r1;  // Copy constructor
        Room r3;
        r3 = r1;       // Assignment operator

        r1.print();
        r2.print();
        r3.print();
    }
    else if (testCase == 2) {
        // Test StandardRoom
        int number, price;
        bool hasBalcony;
        cin >> number >> price >> hasBalcony;

        StandardRoom sr(number, price, hasBalcony);
        sr.print();
    }
    else if (testCase == 3) {
        // Test LuxuryRoom
        int number, price;
        bool hasJacuzzi;
        cin >> number >> price >> hasJacuzzi;

        LuxuryRoom lr(number, price, hasJacuzzi);
        lr.print();
    }
    else if (testCase == 4) {
        // Polymorphism test
        int n;
        cin >> n;
        Room* rooms[100];

        for (int i = 0; i < n; ++i) {
            string type;
            cin >> type;

            int number, price;
            cin >> number >> price;

            if (type == "Standard") {
                bool hasBalcony;
                cin >> hasBalcony;
                rooms[i] = new StandardRoom(number, price, hasBalcony);
            } else if (type == "Luxury") {
                bool hasJacuzzi;
                cin >> hasJacuzzi;
                rooms[i] = new LuxuryRoom(number, price, hasJacuzzi);
            } else {
                rooms[i] = new Room(number, price);
            }
        }

        for (int i = 0; i < n; ++i) {
            rooms[i]->print();
        }

        for (int i = 0; i < n; ++i) {
            delete rooms[i];
        }
    }

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2) Да се дефинира класа MovieActor за која ќе се чуваат:

    динамички алоцирана низа од карактери за името на актерот
    низа од максимум 40 карактери за државата од која потекнува
    просечна оцена на филмовите во кои глумел актерот годинава (double)
    вкупен број на филмови годинава (int)
    вкупна заработка од тие филмови во милиони долари (double)

За потребите на класата да се дефинираат:

    default конструктор и конструктор со аргументи
    copy constructor и оператор =
    деструктор
    метод rating() кој го враќа рејтингот на актерот пресметан како:

    (просечна_оценка * 0.4) + (број_на_филмови * 0.2) + (заработка * 0.4)

    метод print() кој ги печати податоците во следниот формат:

    [Име] - [држава]
    Average rating: [просечна оцена]
    Movies this year: [вкупен број]
    Total earnings: [вкупна заработка]
    Rating: [рејтинг]

Од MovieActor да се изведе класа OscarWinner за која дополнително ќе се чуваат:

    просечна оцена на филмовите по добиениот Оскар (double)
    број на филмови по добиениот Оскар (int)
    вкупна заработка од тие филмови (double)

За потребите на класата да се дефинираат:

    default конструктор
    конструктор кој прима објект од MovieActor и плус дополнителните информации
    конструктор кој ги прима сите аргументи (видете main)
    copy constructor, оператор =, деструктор
    метод oscarRating() кој го враќа рејтингот од пост-Оскар филмовите:

    (пост-оскар_просечна_оценка * 0.6) + (пост-оскар_број_на_филмови * 0.1) + (пост-оскар_заработка * 0.3)

Да се препокријат методите:

    rating() кој враќа просек од основниот и oscar рејтинг
    print() кој покрај основните информации за актерот печати и:

    Oscar Rating: [рејтинг]
    New Rating: [просечниот]

Input
2
3
Leonardo_DiCaprio USA 8.5 3 150.0
9.2 4 200.0
Tom_Hanks USA 9.0 5 200.0
9.5 6 250.0
Meryl_Streep USA 9.5 4 120.0
9.8 7 300.0

Expected
MOVIE ACTORS:
=====================================
Leonardo_DiCaprio - USA
Average rating: 8.5
Movies this year: 3
Total earnings: 150
Rating: 64
-------------------------
Tom_Hanks - USA
Average rating: 9
Movies this year: 5
Total earnings: 200
Rating: 84.6
-------------------------
Meryl_Streep - USA
Average rating: 9.5
Movies this year: 4
Total earnings: 120
Rating: 52.6
-------------------------
OSCAR WINNERS:
=====================================
Leonardo_DiCaprio - USA
Average rating: 8.5
Movies this year: 3
Total earnings: 150
Rating: 64.96
Oscar Rating: 65.92
New Rating: 64.96
-------------------------
Tom_Hanks - USA
Average rating: 9
Movies this year: 5
Total earnings: 200
Rating: 82.95
Oscar Rating: 81.3
New Rating: 82.95
-------------------------
Meryl_Streep - USA
Average rating: 9.5
Movies this year: 4
Total earnings: 120
Rating: 74.59
Oscar Rating: 96.58
New Rating: 74.59


#include <iostream>
#include <cstring>
using namespace std;

class MovieActor {
protected:
    char* name;
    char country[41];
    double avgRating;
    int numMovies;
    double earnings;

public:
    MovieActor() {
        name = new char[1];
        name[0] = '\0';
        country[0] = '\0';
        avgRating = 0;
        numMovies = 0;
        earnings = 0;
    }

    MovieActor(const char* name, const char* country, double avgRating, int numMovies, double earnings) {
        this->name = new char[strlen(name) + 1];
        strcpy(this->name, name);
        strncpy(this->country, country, 40);
        this->country[40] = '\0';
        this->avgRating = avgRating;
        this->numMovies = numMovies;
        this->earnings = earnings;
    }

    MovieActor(const MovieActor& other) {
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
        strcpy(country, other.country);
        avgRating = other.avgRating;
        numMovies = other.numMovies;
        earnings = other.earnings;
    }

    MovieActor& operator=(const MovieActor& other) {
        if (this != &other) {
            delete[] name;
            name = new char[strlen(other.name) + 1];
            strcpy(name, other.name);
            strcpy(country, other.country);
            avgRating = other.avgRating;
            numMovies = other.numMovies;
            earnings = other.earnings;
        }
        return *this;
    }

    virtual ~MovieActor() {
        delete[] name;
    }

    virtual double rating() const {
        return avgRating * 0.4 + numMovies * 0.2 + earnings * 0.4;
    }

    virtual void print() const {
        cout << name << " - " << country << endl;
        cout << "Average rating: " << avgRating << endl;
        cout << "Movies this year: " << numMovies << endl;
        cout << "Total earnings: " << earnings << endl;
        cout << "Rating: " << rating() << endl;
    }
};

class OscarWinner : public MovieActor {
private:
    double postAvgRating;
    int postNumMovies;
    double postEarnings;

public:
    OscarWinner() : MovieActor() {
        postAvgRating = 0;
        postNumMovies = 0;
        postEarnings = 0;
    }

    OscarWinner(const MovieActor& actor, double postAvgRating, int postNumMovies, double postEarnings)
        : MovieActor(actor) {
        this->postAvgRating = postAvgRating;
        this->postNumMovies = postNumMovies;
        this->postEarnings = postEarnings;
    }

    OscarWinner(const char* name, const char* country, double avgRating, int numMovies, double earnings,
                double postAvgRating, int postNumMovies, double postEarnings)
        : MovieActor(name, country, avgRating, numMovies, earnings) {
        this->postAvgRating = postAvgRating;
        this->postNumMovies = postNumMovies;
        this->postEarnings = postEarnings;
    }

    OscarWinner(const OscarWinner& other) : MovieActor(other) {
        postAvgRating = other.postAvgRating;
        postNumMovies = other.postNumMovies;
        postEarnings = other.postEarnings;
    }

    OscarWinner& operator=(const OscarWinner& other) {
        if (this != &other) {
            MovieActor::operator=(other);
            postAvgRating = other.postAvgRating;
            postNumMovies = other.postNumMovies;
            postEarnings = other.postEarnings;
        }
        return *this;
    }

    ~OscarWinner() {}

    double oscarRating() const {
        return postAvgRating * 0.6 + postNumMovies * 0.1 + postEarnings * 0.3;
    }

    double rating() const override {
        // Просек од основниот rating() и oscarRating()
        return (MovieActor::rating() + oscarRating()) / 2.0;
    }

    void print() const override {
        MovieActor::print();
        cout << "Oscar Rating: " << oscarRating() << endl;
        cout << "New Rating: " << rating() << endl;
    }
};

// main даден во прашањето

int main() {
    char name[100];
    char country[41];
    double avg_rating;
    int num_movies;
    double earnings;
    double post_avg_rating;
    int post_num_movies;
    double post_earnings;

    int n;
    cin >> n;

    if (n == 1) {
        // Test MovieActor basic functionality
        cout << "MOVIE ACTORS:" << endl;
        cout << "=====================================" << endl;
        int numActors;
        cin >> numActors;

        MovieActor* actors = new MovieActor[numActors];

        for (int i = 0; i < numActors; ++i) {
            cin >> name >> country >> avg_rating >> num_movies >> earnings;
            actors[i] = MovieActor(name, country, avg_rating, num_movies, earnings);
            actors[i].print();
            cout << "-------------------------" << endl;
        }

        delete[] actors;
    }
    else if (n == 2) {
        // Test MovieActor and create OscarWinner from it
        int numActors;
        cin >> numActors;

        MovieActor* actors = new MovieActor[numActors];
        OscarWinner* oscarWinners = new OscarWinner[numActors];
        for (int i = 0; i < numActors; ++i) {
            cin >> name >> country >> avg_rating >> num_movies >> earnings;
            cin >> post_avg_rating >> post_num_movies >> post_earnings;

            actors[i] = MovieActor(name, country, avg_rating, num_movies, earnings);
            oscarWinners[i] = OscarWinner(actors[i], post_avg_rating, post_num_movies, post_earnings);
        }

        cout << "MOVIE ACTORS:" << endl;
        cout << "=====================================" << endl;
        for (int i = 0; i < numActors; ++i) {
            actors[i].print();
            cout << "-------------------------" << endl;
        }

        cout << "OSCAR WINNERS:" << endl;
        cout << "=====================================" << endl;
        for (int i = 0; i < numActors; ++i) {
            oscarWinners[i].print();
            cout << "-------------------------" << endl;
        }

        delete[] actors;
        delete[] oscarWinners;
    }
    else if (n == 3) {
        // Test OscarWinner with all arguments constructor
        int numWinners;
        cin >> numWinners;

        OscarWinner* oscarWinners = new OscarWinner[numWinners];

        for (int i = 0; i < numWinners; ++i) {
            cin >> name >> country >> avg_rating >> num_movies >> earnings;
            cin >> post_avg_rating >> post_num_movies >> post_earnings;

            oscarWinners[i] = OscarWinner(name, country, avg_rating, num_movies, earnings,
                                          post_avg_rating, post_num_movies, post_earnings);
        }

        cout << "OSCAR WINNERS:" << endl;
        cout << "=====================================" << endl;
        for (int i = 0; i < numWinners; ++i) {
            oscarWinners[i].print();
            cout << "-------------------------" << endl;
        }
        delete[] oscarWinners;
    }
    else if (n == 4) {
        // Test copy constructor and operator= for MovieActor
        MovieActor actor1;
        cin >> name >> country >> avg_rating >> num_movies >> earnings;
        actor1 = MovieActor(name, country, avg_rating, num_movies, earnings);

        MovieActor actor2(actor1); // Using copy constructor
        MovieActor actor3;
        actor3 = actor1;           // Using operator=

        cout << "ORIGINAL:" << endl;
        actor1.print();
        cout << "-------------------------" << endl;

        cout << "COPY CONSTRUCTOR:" << endl;
        actor2.print();
        cout << "-------------------------" << endl;

        cout << "OPERATOR=:" << endl;
        actor3.print();
        cout << "-------------------------" << endl;
    }
    else if (n == 5) {
        // Test copy constructor and operator= for OscarWinner
        OscarWinner winner1;
        cin >> name >> country >> avg_rating >> num_movies >> earnings;
        cin >> post_avg_rating >> post_num_movies >> post_earnings;

        winner1 = OscarWinner(name, country, avg_rating, num_movies, earnings,
                              post_avg_rating, post_num_movies, post_earnings);

        OscarWinner winner2(winner1); // Using copy constructor
        OscarWinner winner3;
        winner3 = winner1;            // Using operator=

        cout << "ORIGINAL:" << endl;
        winner1.print();
        cout << "-------------------------" << endl;

        cout << "COPY CONSTRUCTOR:" << endl;
        winner2.print();
        cout << "-------------------------" << endl;

        cout << "OPERATOR=:" << endl;
        winner3.print();
        cout << "-------------------------" << endl;
    }

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3)
#include <iostream>
#include <cstring>
using namespace std;
class Nedviznina {
protected:
    char *address;
    int kvadrat;
    int c;
    void copy(const Nedviznina& n) {
        this->address=new char[strlen(n.address)+1];
        strcpy(this->address, n.address);
        this->kvadrat=n.kvadrat;
        this->c=n.c;
    }
public:
    Nedviznina(char *address="", int kvadrat=0, int c=0) {
        this->address=new char[strlen(address)+1];
        strcpy(this->address, address);
        this->kvadrat=kvadrat;
        this->c=c;
    }
    Nedviznina(const Nedviznina& n) {
        copy(n);
    }
    Nedviznina& operator=(const Nedviznina& n) {
        if (this!=&n) {
            delete[]address;
            copy(n);
        }
        return *this;
    }
    ~Nedviznina(){delete[]address;}
    int cena() {
        return kvadrat*c;
    }
    void pecati() {
        cout<<address<<" "<<c<<" "<<kvadrat<<endl;
    }
    double danokNaImot() {
        return 0.05*cena();
    }
    friend istream& operator>>(istream& is,  Nedviznina& v) {
        char temp[256];
        is>>temp;
        delete[]v.address;
        v.address=new char[strlen(temp)+1];
        strcpy(v.address,temp);
     is>>v.c>>v.kvadrat;
        return is;
    }
    char* getAdresa() {
        return address;
    }
};
class Vila:public Nedviznina {
    int danok;
public:
    Vila(char *address="", int kvadrat=0, int c=0, int danok=0):Nedviznina(address,kvadrat,c) {
        this->danok=danok;
    }
    Vila(const Vila& v):Nedviznina(v) {
        this->danok=v.danok;
    }
    Vila& operator=(const Vila & v) {
        if (this!=&v) {
            Nedviznina::copy(v);
            this->danok=v.danok;
        }
        return *this;
    }
    ~Vila(){delete[]address;}
    void print() {
       Nedviznina::pecati();
        cout<<danok<<endl;
    }
    friend istream& operator>>(istream& is,  Vila& v) {
        delete[]v.address;
        char temp[256];
        is >> temp;
        v.address = new char[strlen(temp)+1];
        strcpy(v.address, temp);
        is>>v.c>>v.kvadrat>>v.danok;
        return is;
    }
    int danokNaImot() {
        return cena()*(5+danok)/100;
    }
char* getAdresa() {
        return address;
    }
};

int main()
{
    Nedviznina n;
    Vila v;
    cin >> n;
    cin >> v;
    n.pecati();
    cout << "Danok za: " << n.getAdresa() << ", e: " << n.danokNaImot() << endl;
    v.pecati();
    cout << "Danok za: " << v.getAdresa() << ", e: " << v.danokNaImot() << endl;
    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4) Треба да се имплементираат класи за универзитетски настани. Во рамките на почетниот код се дадени класите и основните атрибути и конструктори. Вие треба да ги довршите.

Да се имплементира основната класа UniversityEvent за која ќе се чуваат:

name (динамички алоцирана низа од карактери)
universityHost (динамички алоцирана низа од карактери)
date (динамички алоцирана низа од карактери)
entryFee (int)
За потребите на класата да се дефинираат:

default конструктор и конструктор со аргументи
copy constructor и преоптоварување на операторот за =
виртуелен деструктор
виртуелен метод getEntryFee() кој ја враќа цената
метод registerEvent() кој претставува чист виртуелен метод (pure virtual method) кој ќе се имплементира понатаму во наследените класи. (овој метод е веќе даден во почетниот код)
виртуелен метод print() кој печати во формат:
Event: [name]

Hosted by: [university_host]

Date: [date]

Entry Fee: [entryFee] den.



Да се имплементира класата OnSiteEvent , која наследува од основната класа, за која дополнително се чуваат:

participants (int)
capacity (int)
За потребите на класата да се дефинираат:

default конструктор и конструктор со аргументи (без participants во аргументите, тој атрибут го иницијализираме на 0 по default)
copy constructor и преоптоварување на операторот за =
деструктор
препокривање на методот registerEvent() кој го зголемува бројот на учесници доколку се повика и печати:
You have successfully registered on the OnSiteEvent , you have to pay [entryFee] den. (Доколку има слободно место)
We are sorry, but unfortunately, the capacity is full. (Доколку нема слободно место)
препокривање на методот print() кој покрај основните информации ќе печати и:
Participants: [participants]
Да се имплементира класата OnlineEvent, која наследува од основната класа, за која дополнително се чува:

bbbLink (динамички алоцирана низа од карактери)
За потребите на класата да се дефинираат:

default конструктор и конструктор со аргументи
copy constructor и преоптоварување на операторот за =
деструктор
препокривање на методот getEntryFee() кој че врати 50% од цената бидејќи е онлајн.
препокривање на методот registerEvent() кој печати:
You have successfully registered on the OnlineEvent , you have to pay [entryFee] den.
препокривање на методот print() кој покрај основните информации ќе печати и:
Link: [bbbLink]
input
2
SummerSchool Oxford 2024-07-01 800 100
CloudSummit IBM 2024-09-20 350 https://bbb.com/cloudsummit
Event: SummerSchool
Hosted by: Oxford
Date: 2024-07-01



Event: SummerSchool
Hosted by: Oxford
Date: 2024-07-01
Entry Fee: 800 den.
Participants: 0
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
-------------------------
Event: CloudSummit
Hosted by: IBM
Date: 2024-09-20
Entry Fee: 350 den.
Link: https://bbb.com/cloudsummit
You have successfully registered on the OnlineEvent, you have to pay 175 den.
-------------------------

--- Dynamic OnSiteEvent Capacity Test ---
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.
You have successfully registered on the OnSiteEvent, you have to pay 800 den.

--- OnSiteEvent print() after dynamic test ---
Event: SummerSchool
Hosted by: Oxford
Date: 2024-07-01
Entry Fee: 800 den.
Participants: 11

--- OnSiteEvent Operator= Test (dynamic) ---
Event: SummerSchool
Hosted by: Oxford
Date: 2024-07-01
Entry Fee: 800 den.
Participants: 11

#include<iostream>
#include<cstring>
using namespace std;

class UniversityEvent {
protected:
    char* name;
    char* universityHost;
    char* date;
    int entryFee;
public:
    explicit UniversityEvent(const char* name = "", const char* universityHost = "", const char* date = "", const int entryFee = 0) {
        this->name = new char[strlen(name)+1];
        strcpy(this->name, name);
        this->universityHost = new char[strlen(universityHost)+1];
        strcpy(this->universityHost, universityHost);
        this->date = new char[strlen(date)+1];
        strcpy(this->date, date);
        this->entryFee = entryFee;
    }
    UniversityEvent(const UniversityEvent &other) {
        this->name = new char[strlen(other.name)+1];
        strcpy(this->name, other.name);
        this->universityHost = new char[strlen(other.universityHost)+1];
        strcpy(this->universityHost, other.universityHost);
        this->date = new char[strlen(other.date)+1];
        strcpy(this->date, other.date);
        this->entryFee = other.entryFee;
    }
    virtual ~UniversityEvent() {
        delete[] name;
        delete[] universityHost;
        delete[] date;
    }
    UniversityEvent &operator=(const UniversityEvent &other) {
        if(this != &other) {
            delete[] this->name;
            delete[] this->universityHost;
            delete[] this->date;
            this->name = new char[strlen(other.name)+1];
            strcpy(this->name, other.name);
            this->universityHost = new char[strlen(other.universityHost)+1];
            strcpy(this->universityHost, other.universityHost);
            this->date = new char[strlen(other.date)+1];
            strcpy(this->date, other.date);
            this->entryFee = other.entryFee;
        }
        return *this;
    }
    virtual int getEntryFee() const {
        return entryFee;
    }
    virtual void registerEvent() = 0;
    virtual void print() const {
        cout << "Event: " << name << endl
        << "Hosted by: " << universityHost << endl
        << "Date: " << date << endl
        << "Entry Fee: " << entryFee << " den." << endl;
    }
};

class OnSiteEvent final : public UniversityEvent {
private:
    int participants;
    int capacity;
public:
    explicit OnSiteEvent(const char* name = "", const char* universityHost = "", const char* date = "", const int entryFee = 0,
    const int capacity = 0) : UniversityEvent(name, universityHost, date, entryFee) {
        this->capacity = capacity;
        this->participants = 0;
    }
    OnSiteEvent(const OnSiteEvent &other) : UniversityEvent(other) {
        this->capacity = other.capacity;
        this->participants = other.participants;
    }
    ~OnSiteEvent() override = default;
    OnSiteEvent &operator=(const OnSiteEvent &other) {
        if(this != &other) {
            UniversityEvent::operator=(other);
            this->capacity = other.capacity;
            this->participants = other.participants;
        }
        return *this;
    }
    void registerEvent() override {
        if(participants < capacity) {
            participants++;
            cout << "You have successfully registered on the OnSiteEvent, you have to pay " << getEntryFee() << " den." << endl;
            return;
        }
        cout << "We are sorry, but unfortunately, the capacity is full." << endl;
    }
    void print() const override {
        UniversityEvent::print();
        cout << "Participants: " << participants << endl;
    }
};

class OnlineEvent final : public UniversityEvent {
private:
    char* bbbLink;
public:
    explicit OnlineEvent(const char* name = "", const char* universityHost = "", const char* date = "", const int entryFee = 0,
    const char* bbbLink = "") : UniversityEvent(name, universityHost, date, entryFee) {
        this->bbbLink = new char[strlen(bbbLink)+1];
        strcpy(this->bbbLink, bbbLink);
    }
    OnlineEvent(const OnlineEvent &other) : UniversityEvent(other) {
        this->bbbLink = new char[strlen(other.bbbLink)+1];
        strcpy(this->bbbLink, other.bbbLink);
    }
    ~OnlineEvent() override {
        delete[] bbbLink;
    }
    OnlineEvent &operator=(const OnlineEvent &other) {
        if(this != &other) {
            UniversityEvent::operator=(other);
            delete[] this->bbbLink;
            this->bbbLink = new char[strlen(other.bbbLink)+1];
            strcpy(this->bbbLink, other.bbbLink);
        }
        return *this;
    }
    int getEntryFee() const override {
        return UniversityEvent::getEntryFee() * 0.5;
    }
    void registerEvent() override {
        cout << "You have successfully registered on the OnlineEvent, you have to pay " << getEntryFee() << " den." << endl;
    }
    void print() const override {
        UniversityEvent::print();
        cout << "Link: " << bbbLink << endl;
    }
};

int main() {
    int n;
    cin >> n;

    UniversityEvent** events = new UniversityEvent*[n];

    char name[100];
    char universityHost[100];
    char date[100];
    int entryFee;

    for (int i = 0; i < n; i++) {
        cin >> name;
        cin >> universityHost;
        cin >> date;
        cin >> entryFee;

        if (i % 2 == 0) {
            int capacity;
            cin >> capacity;
            events[i] = new OnSiteEvent(name, universityHost, date, entryFee, capacity);
        } else {
            char bbbLink[200];
            cin >> bbbLink;
            events[i] = new OnlineEvent(name, universityHost, date, entryFee, bbbLink);
        }
    }

    for (int i = 0; i < n; i++) {
        events[i]->print();
        events[i]->registerEvent();
        cout << "-------------------------\n";
    }

    // Test OnSiteEvent.registerEvent() edge cases using first event dynamically
    cout << "\n--- Dynamic OnSiteEvent Capacity Test ---\n";
    OnSiteEvent* testEvent = dynamic_cast<OnSiteEvent*>(events[0]);
    for (int i = 0; i < 10; ++i) {
        testEvent->registerEvent();
    }

    cout << "\n--- OnSiteEvent print() after dynamic test ---\n";
    testEvent->print();

    // Test operator=
    cout << "\n--- OnSiteEvent Operator= Test (dynamic) ---\n";
    OnSiteEvent assignedEvent;
    assignedEvent = *testEvent;
    assignedEvent.print();

    // Cleanup
    for (int i = 0; i < n; i++) delete events[i];
    delete[] events;

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5) Да се дефинира класа Scientist за која ќе се чуваат:

динамички алоцирана низа од карактери за името на научникот

низа од максимум 50 карактери за институцијата каде што работи

вкупен број објавени трудови (int)

вкупен број цитати од тие трудови (int)

вкупен број години истражувачка работа (int)

За потребите на класата да се дефинираат:

default конструктор и конструктор со аргументи

copy constructor и оператор =

деструктор

метод impact() кој го враќа научниот импакт според формулата: (цитати * 0.5 + трудови * 0.3 + години * 0.2)

метод print() кој печати:

Name: <име> - Institution: <институција>  
Publications: <трудови>  
Citations: <цитати>  
Experience: <години>  
Impact Score: <импакт>

Input	Result
1
2
Alice ResearchLab 10 100 5
Bob InstituteA 20 200 10
SCIENTISTS:
=====================================
Alice - ResearchLab
Publications: 10
Citations: 100
Experience (Years): 5
Impact Score: 54
-------------------------
Bob - InstituteA
Publications: 20
Citations: 200
Experience (Years): 10
Impact Score: 108
-------------------------
Testing Copy Constructor:
Alice - ResearchLab
Publications: 10
Citations: 100
Experience (Years): 5
Impact Score: 54
Testing Assignment Operator:
Bob - InstituteA
Publications: 20
Citations: 200
Experience (Years): 10
Impact Score: 108

#include <iostream>
#include <cstring>
using namespace std;

class Scientist {
private:
    char* name;
    char institution[51];
    int publications;
    int citations;
    int years;

public:
    Scientist() {
        name = new char[1];
        name[0] = '\0';
        institution[0] = '\0';
        publications = 0;
        citations = 0;
        years = 0;
    }

    Scientist(const char* _name, const char* _institution, int _publications, int _citations, int _years) {
        name = new char[strlen(_name) + 1];
        strcpy(name, _name);
        strncpy(institution, _institution, 50);
        institution[50] = '\0';
        publications = _publications;
        citations = _citations;
        years = _years;
    }

    Scientist(const Scientist& other) {
        name = new char[strlen(other.name) + 1];
        strcpy(name, other.name);
        strcpy(institution, other.institution);
        publications = other.publications;
        citations = other.citations;
        years = other.years;
    }

    Scientist& operator=(const Scientist& other) {
        if (this != &other) {
            delete[] name;
            name = new char[strlen(other.name) + 1];
            strcpy(name, other.name);
            strcpy(institution, other.institution);
            publications = other.publications;
            citations = other.citations;
            years = other.years;
        }
        return *this;
    }

    ~Scientist() {
        delete[] name;
    }

    int impact() const {
        double score = citations * 0.5 + publications * 0.3 + years * 0.2;
        return static_cast<int>(score);
    }

    void print() const {
        cout << name << " - " << institution << endl;
        cout << "Publications: " << publications << endl;
        cout << "Citations: " << citations << endl;
        cout << "Experience (Years): " << years << endl;
        cout << "Impact Score: " << impact() << endl;
    }
};

int main() {
    int n;
    cin >> n;

    if (n == 1) {
        int numScientists;
        cin >> numScientists;

        Scientist* scientists = new Scientist[numScientists];

        for (int i = 0; i < numScientists; ++i) {
            char name[100], institutiontitution[50];
            int publications, citons, years;
            cin >> name >> institutiontitution >> publications >> citons >> years;

            scientists[i] = Scientist(name, institutiontitution, publications, citons, years);
        }

        cout << "SCIENTISTS:" << endl;
        cout << "=====================================" << endl;
        for (int i = 0; i < numScientists; ++i) {
            scientists[i].print();
            cout << "-------------------------" << endl;
        }

        cout << "Testing Copy Constructor:" << endl;
        Scientist copiedScientist = scientists[0];
        copiedScientist.print();

        cout << "Testing Assignment Operator:" << endl;
        Scientist assignedScientist;
        assignedScientist = scientists[1];
        assignedScientist.print();

        delete[] scientists;
    }

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

6) Потребно е да креирате систем за членство во една теретана. За таа цел, најпрво ќе креирате една класа Membership со информации за:

име на членот - низа од максимум 50 знаци
ден на зачленување - низа од максимум 11 знаци (2025-05-05)
месечна членарина - цел број
За основната класа треба да креирате:

Default конструктор
Конструктор со параметри
Copy конструктор
Оператор =
Функција која ќе ја враќа вредноста на месечната членарина (getMonthlyFee)
Функција print што ги печати информациите за членот во формат:
[име и презиме] - [датум на зачленување]


Понатаму потребно е да развиете две класи: BasicMembership и VIPMembership

Класата BasicMembership треба да содржи информација isMorningMembership - boolean вредност за тоа дали членот смее да вежба само до 15:00.



За оваа класа потребно е да креирате:

Default конструктор
Конструктор со параметри
Функција што ќе ја враќа вредноста на месечната членарина (getMonthlyFee), пресметана така што доколку членот смее да вежба само до 15:00, добива 25% попуст на основната месечна членарина. Пример: Доколку месечната членарина е 2000 денари и членот вежба само наутро, оваа функција ќе врати вредност 1500 денари (2000-0.25*2000 = 1500), инаку се добива стандардната висина на месечната членарина.
Функција print што ги печати информациите за членот во формат:
[име и презиме] - [датум на зачленување] - [месечна членарина] - [вежба до 15:00 - yes/no]


Вашата теретана е многу модерна и има спа која е пристаплива само за VIP членовите. Класата VIPMembership треба да содржи информации за:

дали членот го користи спа просторот - boolean вредност
колку часа членот вежбал со тренер - цел број
За оваа класа потребно е да креирате:

Default конструктор
Конструктор со параметри
Функција што ќе ја враќа вредноста на месечната членарина (getMonthlyFee), пресметана така што доколку членот го користи спа просторот, висината се зголемува за 1000 денари. Во пресметката се додава и бројот на часови со тренер. Цена на еден час е 150 денари. Пример: Основната членарина е 2000 денари. Членот го користи спа просторот и вежбал 10 часа со тренер: 2000 + 1000 + 10*150 = 4500 денари.
Функција print што ги печати информациите за членот во формат:
[име и презиме] - [датум на зачленување] - [месечна членарина] - [користи спа - yes/no] - [вкупна сума платена за тренер]

Input	
2
John
2025-01-01
2000
1 10
Mark
2025-03-06
1400
1
Result
John - 2025-01-01 - 4500 - yes - 1500
Mark - 2025-03-06 - 1050 - yes

#include <iostream>
#include <cstring>
using namespace std;

class Membership {
protected:
    char name[51];
    char dateJoined[11];
    int monthlyFee;

public:
    Membership() {
        name[0] = '\0';
        dateJoined[0] = '\0';
        monthlyFee = 0;
    }

    Membership(const char* _name, const char* _dateJoined, int _monthlyFee) {
        strncpy(name, _name, 50);
        name[50] = '\0';
        strncpy(dateJoined, _dateJoined, 10);
        dateJoined[10] = '\0';
        monthlyFee = _monthlyFee;
    }

    Membership(const Membership& other) {
        strcpy(name, other.name);
        strcpy(dateJoined, other.dateJoined);
        monthlyFee = other.monthlyFee;
    }

    Membership& operator=(const Membership& other) {
        if (this != &other) {
            strcpy(name, other.name);
            strcpy(dateJoined, other.dateJoined);
            monthlyFee = other.monthlyFee;
        }
        return *this;
    }

    virtual int getMonthlyFee() const {
        return monthlyFee;
    }

    virtual void print() const {
        cout << name << " - " << dateJoined << endl;
    }

    virtual ~Membership() {}
};

class BasicMembership : public Membership {
private:
    bool isMorningMembership;

public:
    BasicMembership() : Membership() {
        isMorningMembership = false;
    }

    BasicMembership(const Membership& m, bool _isMorningMembership) : Membership(m) {
        isMorningMembership = _isMorningMembership;
    }

    int getMonthlyFee() const override {
        if (isMorningMembership)
            return monthlyFee - (monthlyFee / 4);
        return monthlyFee;
    }

    void print() const override {
        cout << name << " - " << dateJoined << " - " << getMonthlyFee() << " - ";
        cout << (isMorningMembership ? "yes" : "no") << endl;
    }
};

class VIPMembership : public Membership {
private:
    bool usesSpa;
    int numOfHoursWithTrainer;

public:
    VIPMembership() : Membership() {
        usesSpa = false;
        numOfHoursWithTrainer = 0;
    }

    VIPMembership(const Membership& m, bool _usesSpa, int _numOfHoursWithTrainer) : Membership(m) {
        usesSpa = _usesSpa;
        numOfHoursWithTrainer = _numOfHoursWithTrainer;
    }

    int getMonthlyFee() const override {
        int total = monthlyFee;
        if (usesSpa) total += 1000;
        total += numOfHoursWithTrainer * 150;
        return total;
    }

    void print() const override {
        cout << name << " - " << dateJoined << " - " << getMonthlyFee() << " - ";
        cout << (usesSpa ? "yes" : "no");
        if (usesSpa)
            cout << " - " << numOfHoursWithTrainer * 150;
        cout << endl;
    }
};

int main()
{
    int n;
    cin >> n;
    char name[50];
    char dateJoined[11];
    int membershipPrice;

    for (int i = 0; i < n; i++)
    {
        cin >> name;
        cin >> dateJoined;
        cin >> membershipPrice;

        Membership m = Membership(name, dateJoined, membershipPrice);

        if (i % 2)
        {
            bool isMorningMembership;
            cin >> isMorningMembership;
            BasicMembership bm = BasicMembership(m, isMorningMembership);
            bm.print();
        }
        else
        {
            bool usesSpa;
            int numOfHoursWithTrainer;
            cin >> usesSpa >> numOfHoursWithTrainer;
            VIPMembership vm = VIPMembership(m, usesSpa, numOfHoursWithTrainer);
            vm.print();
        }
    }

    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7) Да се дефинира класа Theater за која ќе се чуваат:

динамички алоцирана низа од карактери за името на театарот
динамички алоцирана низа од карактери за градот во кој се наоѓа театарот
капацитет (int)
низа од 10 оцени за театарот (double)
основна цена на карта (double)
процент на попуст (број од 0-100) (int)
За потребите на класата да се дефинираат:

default конструктор и конструктор со аргументи
copy constructor и оператор =
деструктор
метод avgRating() кој ја враќа просечната оцена:


метода finalTicketPrice():

За просечна оцена понизка од 2.0 основната цена се намалува за 20%
За просечна оцена понизка од 4.0 основната цена не се менува
За просечна оцена повисока и еднаква на 4.0 основната цена се зголемува за 20%
Потоа се пресметува процентот за попуст

метод print() кој го печати тркачот во следниот формат:

Тheater name - име на театарот

City- градот во кој се наоѓа театарот

Rating: просечната оцена

Ticket price: конечната цена на билет

Од претходната класа Theater да се изведе класата MovieTheater за која дополнително ќе се чуваат и:

ширина на екран (double)
висина на екран (double)
дали е 3Д (bool)
За потребите на класата да се дефинираат:

default конструктор
конструктор кој ги прима сите аргументи (од основната класа и дополнителните oд изведената класа) (погледни main)
copy constructor и оператор =
деструктор
Да се препокријат методите:
finalTicketPrice():

Доколку киното е 3Д, основната цена на билет се зголемува 30%
Ако не е, останува иста
Потоа се пресметува процентот за попуст
print() кој покрај основните информации печати и:
Screen Width: ширина на екранот
Screen Height: висина на екранор
Is 3D: дали е 3Д
Да се имплементира глобалната функција MostExpensiveTheater() - прима низа од покажувачи од класата Theater (објектите можат да бидат и Theater и MovieTheater и број на елементи). 
Како резултат се печатат информациите за најскапиот елемент во низата (без разлика дали е Theater или MovieTheater).

#include<iostream>
#include<cstring>
using namespace std;

class Theater {
protected:
    char* name;
    char* city;
    int capacity;
    double reviews[10];
    double price;
    int discount;
public:
    explicit Theater(const char* name = "", const char* city = "", const int capacity = 0, const double* reviews = nullptr,
    const double price = 0.0, const int discount = 0) {
        this->name = new char[strlen(name)+1];
        strcpy(this->name, name);
        this->city = new char[strlen(city)+1];
        strcpy(this->city, city);
        this->capacity = capacity;
        this->price = price;
        this->discount = discount;
        if(reviews != nullptr) {
            for(int i = 0; i < 10; i++) {
                this->reviews[i] = reviews[i];
            }
        }
        else {
            for(double &review : this->reviews) {
                review = 0.0;
            }
        }
    }
    Theater(const Theater &other) {
        this->name = new char[strlen(other.name)+1];
        strcpy(this->name, name);
        this->city = new char[strlen(other.city)+1];
        strcpy(this->city, other.city);
        this->capacity = other.capacity;
        this->price = other.price;
        this->discount = other.discount;
        for(int i = 0; i < 10; i++) {
            this->reviews[i] = other.reviews[i];
        }
    }
    virtual ~Theater() {
        delete[] name;
        delete[] city;
    }
    Theater &operator=(const Theater &other) {
        if(this != &other) {
            delete[] this->name;
            delete[] this->city;
            this->name = new char[strlen(other.name)+1];
            strcpy(this->name, name);
            this->city = new char[strlen(other.city)+1];
            strcpy(this->city, other.city);
            this->capacity = other.capacity;
            this->price = other.price;
            this->discount = other.discount;
            for(int i = 0; i < 10; i++) {
                this->reviews[i] = other.reviews[i];
            }
        }
        return *this;
    }
    virtual double avgRating() const {
        double result = 0.0;
        for(const double review : reviews) {
            result += review;
        }
        return result / 10;
    }
    virtual double finalTicketPrice() const {
        double avg_rating = avgRating();
        return price * (avg_rating < 2.0 ? 0.8 : avg_rating >= 4.0 ? 1.2 : 1.0) * (1 - discount / 100.0);
    }
    virtual void print() const {
        cout << "Theater name - " << name << "\n"
        << "City: " << city << "\n"
        << "Rating: " << avgRating() << "\n"
        << "Ticket price: " << finalTicketPrice() << "\n";
    }
};

class MovieTheater final : public Theater {
private:
    double width;
    double height;
    bool is3D;
public:
    explicit MovieTheater(const char* name = "", const char* city = "", const int capacity = 0, const double* reviews = nullptr,
    const double price = 0.0, const int discount = 0, const double width = 0.0, const double height = 0.0,
    const bool is3D = false) : Theater(name, city, capacity, reviews, price, discount) {
        this->width = width;
        this->height = height;
        this->is3D = is3D;
    }
    MovieTheater(const MovieTheater &other) : Theater(other) {
        this->width = other.width;
        this->height = other.height;
        this->is3D = other.is3D;
    }
    ~MovieTheater() override = default;
    MovieTheater &operator=(const MovieTheater &other) {
        if(this != &other) {
            Theater::operator=(other);
            this->width = other.width;
            this->height = other.height;
            this->is3D = other.is3D;
        }
        return *this;
    }
    double finalTicketPrice() const override {
        return price * (is3D ? 1.3 : 1.0) * (1 - discount / 100.0);
    }
    void print() const override {
        Theater::print();
        cout << "Screen Width: " << width << "\n"
        << "Screen Height: " << height << "\n"
        << "Is 3D: " << (is3D ? "yes\n" : "no\n");
    }
};

void MostExpensiveTheater(const int n, Theater** theaters) {
    int index = 0;
    for(int i = 1; i < n; i++) {
        if(theaters[i]->finalTicketPrice() > theaters[index]->finalTicketPrice()) {
            index = i;
        }
    }
    theaters[index]->Theater::print();
}

int main() {
    int n;
    cin >> n;

    char name[100];
    char city[100];
    int capacity;
    double reviews[10];
    double baseTicketPrice;
    int discount;
    double screenWidth, screenHeight;
    bool is3D;

    if (n == 1) {
        cout << "TESTING CLASS THEATER:" << endl;
        cout << "==============================" << endl;
        for (int i = 0; i < 3; ++i) {
            cin >> name >> city >> capacity;
            for (int j = 0; j < 10; ++j)
                cin >> reviews[j];
            cin >> baseTicketPrice >> discount;

            Theater t(name, city, capacity, reviews, baseTicketPrice, discount);
            t.print();
            cout << "------------------------------";
        }
    } else if (n == 2) {
        cout << "TESTING CLASS MOVIE THEATERS:" << endl;
        cout << "==============================" << endl;
        for (int i = 0; i < 3; ++i) {
            cin >> name >> city >> capacity;
            for (int j = 0; j < 10; ++j)
                cin >> reviews[j];
            cin >> baseTicketPrice >> discount >> screenWidth >> screenHeight >> is3D;

            MovieTheater mt(name, city, capacity, reviews, baseTicketPrice, discount, screenWidth, screenHeight, is3D);
            mt.print();
            cout << "------------------------------";
        }
    } else if (n == 3) {
        cout << "TESTING MostExpensiveTheater FUNCTION:" << endl;
        cout << "==============================" << endl;

        Theater *theaters[6];
        int type;
        for (int i = 0; i < 5; ++i) {
            cin >> type;

            if (type == 1) { // Theater
                cin >> name >> city >> capacity;
                for (int j = 0; j < 10; ++j)
                    cin >> reviews[j];
                cin >> baseTicketPrice >> discount;
                theaters[i] = new Theater(name, city, capacity, reviews, baseTicketPrice, discount);
            } else { // MovieTheater
                cin >> name >> city >> capacity;
                for (int j = 0; j < 10; ++j)
                    cin >> reviews[j];
                cin >> baseTicketPrice >> discount;
                cin >> screenWidth >> screenHeight >> is3D;
                theaters[i] = new MovieTheater(name, city, capacity, reviews, baseTicketPrice, discount,
                screenWidth, screenHeight, is3D);
            }
        }

        MostExpensiveTheater(5, theaters);

        for (int i = 0; i < 5; ++i) {
            delete theaters[i];
        }
    }
}
